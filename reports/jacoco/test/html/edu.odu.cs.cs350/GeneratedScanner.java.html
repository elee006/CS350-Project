<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GeneratedScanner.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">CS350-Project</a> &gt; <a href="index.source.html" class="el_package">edu.odu.cs.cs350</a> &gt; <span class="el_source">GeneratedScanner.java</span></div><h1>GeneratedScanner.java</h1><pre class="source lang-java linenums">// DO NOT EDIT
// Generated by JFlex 1.8.2 http://jflex.de/
// source: /home/runner/work/CS350-Project/CS350-Project/src/main/jflex/token.jflex

package edu.odu.cs.cs350;
//@SupressWarnings(&quot;unused&quot;)


/**
*https://git.cs.odu.edu/zeil/jflexdemo/-/blob/master/src/main/jflex/demo.jflex
*/

// See https://github.com/jflex-de/jflex/issues/222
@SuppressWarnings(&quot;FallThrough&quot;)
public class GeneratedScanner {

  /** This character denotes the end of file. */
  public static final int YYEOF = -1;

  /** Initial size of the lookahead buffer. */
  private static final int ZZ_BUFFERSIZE = 16384;

  // Lexical states.
  public static final int YYINITIAL = 0;

  /**
   * ZZ_LEXSTATE[l] is the state in the DFA for the lexical state l
   * ZZ_LEXSTATE[l+1] is the state in the DFA for the lexical state l
   *                  at the beginning of a line
   * l is of the form l = 2*k, k a non negative integer
   */
<span class="fc" id="L32">  private static final int ZZ_LEXSTATE[] = {</span>
     0, 0
  };

  /**
   * Top-level table for translating characters to character classes
   */
<span class="fc" id="L39">  private static final int [] ZZ_CMAP_TOP = zzUnpackcmap_top();</span>

  private static final String ZZ_CMAP_TOP_PACKED_0 =
    &quot;\1\0\1\u0100\1\u0200\1\u0300\1\u0400\1\u0500\1\u0600\1\u0700&quot;+
    &quot;\1\u0800\1\u0900\1\u0a00\1\u0b00\1\u0c00\1\u0d00\1\u0e00\1\u0f00&quot;+
    &quot;\1\u1000\1\u0100\1\u1100\1\u1200\1\u1300\1\u0100\1\u1400\1\u1500&quot;+
    &quot;\1\u1600\1\u1700\1\u1800\1\u1900\1\u1a00\1\u1b00\1\u0100\1\u1c00&quot;+
    &quot;\1\u1d00\1\u1e00\12\u1f00\1\u2000\1\u2100\1\u2200\1\u1f00\1\u2300&quot;+
    &quot;\1\u2400\2\u1f00\31\u0100\1\u2500\121\u0100\1\u2600\4\u0100\1\u2700&quot;+
    &quot;\1\u0100\1\u2800\1\u2900\1\u2a00\1\u2b00\1\u2c00\1\u2d00\53\u0100&quot;+
    &quot;\1\u2e00\41\u1f00\1\u0100\1\u2f00\1\u3000\1\u0100\1\u3100\1\u3200&quot;+
    &quot;\1\u3300\1\u3400\1\u3500\1\u3600\1\u3700\1\u3800\1\u3900\1\u0100&quot;+
    &quot;\1\u3a00\1\u3b00\1\u3c00\1\u3d00\1\u3e00\1\u3f00\3\u1f00\1\u4000&quot;+
    &quot;\1\u4100\1\u4200\1\u4300\1\u4400\1\u4500\1\u4600\1\u4700\1\u4800&quot;+
    &quot;\1\u1f00\1\u4900\1\u1f00\1\u4a00\1\u4b00\2\u1f00\3\u0100\1\u4c00&quot;+
    &quot;\1\u4d00\1\u4e00\12\u1f00\4\u0100\1\u4f00\17\u1f00\2\u0100\1\u5000&quot;+
    &quot;\41\u1f00\2\u0100\1\u5100\1\u5200\3\u1f00\1\u5300\27\u0100\1\u5400&quot;+
    &quot;\2\u0100\1\u5500\45\u1f00\1\u0100\1\u5600\1\u5700\11\u1f00\1\u5800&quot;+
    &quot;\24\u1f00\1\u5900\1\u5a00\1\u1f00\1\u5b00\1\u5c00\1\u5d00\1\u5e00&quot;+
    &quot;\2\u1f00\1\u5f00\5\u1f00\1\u6000\7\u1f00\1\u6100\1\u6200\4\u1f00&quot;+
    &quot;\1\u6300\21\u1f00\246\u0100\1\u6400\20\u0100\1\u6500\1\u6600\25\u0100&quot;+
    &quot;\1\u6700\34\u0100\1\u6800\14\u1f00\2\u0100\1\u6900\u0b05\u1f00\1\u6a00&quot;+
    &quot;\1\u6b00\u02fe\u1f00&quot;;

  private static int [] zzUnpackcmap_top() {
<span class="fc" id="L64">    int [] result = new int[4352];</span>
<span class="fc" id="L65">    int offset = 0;</span>
<span class="fc" id="L66">    offset = zzUnpackcmap_top(ZZ_CMAP_TOP_PACKED_0, offset, result);</span>
<span class="fc" id="L67">    return result;</span>
  }

  private static int zzUnpackcmap_top(String packed, int offset, int [] result) {
<span class="fc" id="L71">    int i = 0;       /* index in packed string  */</span>
<span class="fc" id="L72">    int j = offset;  /* index in unpacked array */</span>
<span class="fc" id="L73">    int l = packed.length();</span>
<span class="fc bfc" id="L74" title="All 2 branches covered.">    while (i &lt; l) {</span>
<span class="fc" id="L75">      int count = packed.charAt(i++);</span>
<span class="fc" id="L76">      int value = packed.charAt(i++);</span>
<span class="fc bfc" id="L77" title="All 2 branches covered.">      do result[j++] = value; while (--count &gt; 0);</span>
<span class="fc" id="L78">    }</span>
<span class="fc" id="L79">    return j;</span>
  }


  /**
   * Second-level tables for translating characters to character classes
   */
<span class="fc" id="L86">  private static final int [] ZZ_CMAP_BLOCKS = zzUnpackcmap_blocks();</span>

  private static final String ZZ_CMAP_BLOCKS_PACKED_0 =
    &quot;\11\0\1\1\1\2\1\3\1\1\1\4\16\0\4\3&quot;+
    &quot;\1\1\3\3\1\5\6\3\1\6\4\3\12\7\3\3&quot;+
    &quot;\1\10\3\3\32\5\4\3\1\11\1\3\32\5\4\3&quot;+
    &quot;\41\0\2\3\4\5\4\3\1\5\2\3\1\0\7\3&quot;+
    &quot;\1\5\4\3\1\5\5\3\27\5\1\3\37\5\1\3&quot;+
    &quot;\u01ca\5\4\3\14\5\16\3\5\5\7\3\1\5\1\3&quot;+
    &quot;\1\5\21\3\160\0\5\5\1\3\2\5\2\3\4\5&quot;+
    &quot;\1\3\1\5\6\3\1\5\1\3\3\5\1\3\1\5&quot;+
    &quot;\1\3\24\5\1\3\123\5\1\3\213\5\1\3\5\0&quot;+
    &quot;\2\3\246\5\1\3\46\5\2\3\1\5\7\3\47\5&quot;+
    &quot;\7\3\1\5\1\3\55\0\1\3\1\0\1\3\2\0&quot;+
    &quot;\1\3\2\0\1\3\1\0\10\3\33\5\5\3\3\5&quot;+
    &quot;\15\3\6\0\5\3\1\5\4\3\13\0\1\3\1\0&quot;+
    &quot;\3\3\53\5\37\0\4\3\2\5\1\0\143\5\1\3&quot;+
    &quot;\1\5\10\0\1\3\6\0\2\5\2\0\1\3\4\0&quot;+
    &quot;\2\5\12\0\3\5\2\3\1\5\17\3\1\0\1\5&quot;+
    &quot;\1\0\36\5\33\0\2\3\131\5\13\0\1\5\16\3&quot;+
    &quot;\12\0\41\5\11\0\2\5\4\3\1\5\5\3\26\5&quot;+
    &quot;\4\0\1\5\11\0\1\5\3\0\1\5\5\0\22\3&quot;+
    &quot;\31\5\3\0\4\3\13\5\65\3\25\5\1\3\10\5&quot;+
    &quot;\26\3\60\0\66\5\3\0\1\5\22\0\1\5\7\0&quot;+
    &quot;\12\5\2\0\2\3\12\0\1\3\20\5\3\0\1\3&quot;+
    &quot;\10\5\2\3\2\5\2\3\26\5\1\3\7\5\1\3&quot;+
    &quot;\1\5\3\3\4\5\2\3\1\0\1\5\7\0\2\3&quot;+
    &quot;\2\0\2\3\3\0\1\5\10\3\1\0\4\3\2\5&quot;+
    &quot;\1\3\3\5\2\0\2\3\12\0\4\5\7\3\2\5&quot;+
    &quot;\4\3\3\0\1\3\6\5\4\3\2\5\2\3\26\5&quot;+
    &quot;\1\3\7\5\1\3\2\5\1\3\2\5\1\3\2\5&quot;+
    &quot;\2\3\1\0\1\3\5\0\4\3\2\0\2\3\3\0&quot;+
    &quot;\3\3\1\0\7\3\4\5\1\3\1\5\7\3\14\0&quot;+
    &quot;\3\5\1\0\13\3\3\0\1\3\11\5\1\3\3\5&quot;+
    &quot;\1\3\26\5\1\3\7\5\1\3\2\5\1\3\5\5&quot;+
    &quot;\2\3\1\0\1\5\10\0\1\3\3\0\1\3\3\0&quot;+
    &quot;\2\3\1\5\17\3\2\5\2\0\2\3\12\0\1\3&quot;+
    &quot;\1\5\7\3\1\5\6\0\1\3\3\0\1\3\10\5&quot;+
    &quot;\2\3\2\5\2\3\26\5\1\3\7\5\1\3\2\5&quot;+
    &quot;\1\3\5\5\2\3\1\0\1\5\7\0\2\3\2\0&quot;+
    &quot;\2\3\3\0\10\3\2\0\4\3\2\5\1\3\3\5&quot;+
    &quot;\2\0\2\3\12\0\1\3\1\5\20\3\1\0\1\5&quot;+
    &quot;\1\3\6\5\3\3\3\5\1\3\4\5\3\3\2\5&quot;+
    &quot;\1\3\1\5\1\3\2\5\3\3\2\5\3\3\3\5&quot;+
    &quot;\3\3\14\5\4\3\5\0\3\3\3\0\1\3\4\0&quot;+
    &quot;\2\3\1\5\6\3\1\0\16\3\12\0\11\3\1\5&quot;+
    &quot;\6\3\4\0\1\3\10\5\1\3\3\5\1\3\27\5&quot;+
    &quot;\1\3\20\5\3\3\1\5\7\0\1\3\3\0\1\3&quot;+
    &quot;\4\0\7\3\2\0\1\3\3\5\5\3\2\5\2\0&quot;+
    &quot;\2\3\12\0\20\3\1\5\3\0\1\3\10\5\1\3&quot;+
    &quot;\3\5\1\3\27\5\1\3\12\5\1\3\5\5\2\3&quot;+
    &quot;\1\0\1\5\7\0\1\3\3\0\1\3\4\0\7\3&quot;+
    &quot;\2\0\7\3\1\5\1\3\2\5\2\0\2\3\12\0&quot;+
    &quot;\1\3\2\5\15\3\4\0\1\3\10\5\1\3\3\5&quot;+
    &quot;\1\3\51\5\2\0\1\5\7\0\1\3\3\0\1\3&quot;+
    &quot;\4\0\1\5\5\3\3\5\1\0\7\3\3\5\2\0&quot;+
    &quot;\2\3\12\0\12\3\6\5\2\3\2\0\1\3\22\5&quot;+
    &quot;\3\3\30\5\1\3\11\5\1\3\1\5\2\3\7\5&quot;+
    &quot;\3\3\1\0\4\3\6\0\1\3\1\0\1\3\10\0&quot;+
    &quot;\6\3\12\0\2\3\2\0\15\3\60\5\1\0\2\5&quot;+
    &quot;\7\0\4\3\10\5\10\0\1\3\12\0\47\3\2\5&quot;+
    &quot;\1\3\1\5\2\3\2\5\1\3\1\5\2\3\1\5&quot;+
    &quot;\6\3\4\5\1\3\7\5\1\3\3\5\1\3\1\5&quot;+
    &quot;\1\3\1\5\2\3\2\5\1\3\4\5\1\0\2\5&quot;+
    &quot;\6\0\1\3\2\0\1\5\2\3\5\5\1\3\1\5&quot;+
    &quot;\1\3\6\0\2\3\12\0\2\3\4\5\40\3\1\5&quot;+
    &quot;\27\3\2\0\6\3\12\0\13\3\1\0\1\3\1\0&quot;+
    &quot;\1\3\1\0\4\3\2\0\10\5\1\3\44\5\4\3&quot;+
    &quot;\24\0\1\3\2\0\5\5\13\0\1\3\44\0\11\3&quot;+
    &quot;\1\0\71\3\53\5\24\0\1\5\12\0\6\3\6\5&quot;+
    &quot;\4\0\4\5\3\0\1\5\3\0\2\5\7\0\3\5&quot;+
    &quot;\4\0\15\5\14\0\1\5\17\0\2\3\46\5\1\3&quot;+
    &quot;\1\5\5\3\1\5\2\3\53\5\1\3\115\5\1\3&quot;+
    &quot;\4\5\2\3\7\5\1\3\1\5\1\3\4\5\2\3&quot;+
    &quot;\51\5\1\3\4\5\2\3\41\5\1\3\4\5\2\3&quot;+
    &quot;\7\5\1\3\1\5\1\3\4\5\2\3\17\5\1\3&quot;+
    &quot;\71\5\1\3\4\5\2\3\103\5\2\3\3\0\40\3&quot;+
    &quot;\20\5\20\3\126\5\2\3\6\5\3\3\u016c\5\2\3&quot;+
    &quot;\21\5\1\3\32\5\5\3\113\5\3\3\13\5\7\3&quot;+
    &quot;\15\5\1\3\4\5\3\0\13\3\22\5\3\0\13\3&quot;+
    &quot;\22\5\2\0\14\3\15\5\1\3\3\5\1\3\2\0&quot;+
    &quot;\14\3\64\5\40\0\3\3\1\5\3\3\2\5\1\0&quot;+
    &quot;\2\3\12\0\41\3\4\0\1\3\12\0\6\3\130\5&quot;+
    &quot;\10\3\5\5\2\0\42\5\1\0\1\5\5\3\106\5&quot;+
    &quot;\12\3\37\5\1\3\14\0\4\3\14\0\12\3\12\0&quot;+
    &quot;\36\5\2\3\5\5\13\3\54\5\4\3\32\5\6\3&quot;+
    &quot;\12\0\46\3\27\5\5\0\4\3\65\5\12\0\1\3&quot;+
    &quot;\35\0\2\3\13\0\6\3\12\0\15\3\1\5\10\3&quot;+
    &quot;\16\0\102\3\5\0\57\5\21\0\7\5\4\3\12\0&quot;+
    &quot;\21\3\11\0\14\3\3\0\36\5\15\0\2\5\12\0&quot;+
    &quot;\54\5\16\0\14\3\44\5\24\0\10\3\12\0\3\3&quot;+
    &quot;\3\5\12\0\44\5\2\3\11\5\107\3\3\0\1\3&quot;+
    &quot;\25\0\4\5\1\0\4\5\3\0\2\5\3\0\6\3&quot;+
    &quot;\300\5\72\0\1\3\5\0\26\5\2\3\6\5\2\3&quot;+
    &quot;\46\5\2\3\6\5\2\3\10\5\1\3\1\5\1\3&quot;+
    &quot;\1\5\1\3\1\5\1\3\37\5\2\3\65\5\1\3&quot;+
    &quot;\7\5\1\3\1\5\3\3\3\5\1\3\7\5\3\3&quot;+
    &quot;\4\5\2\3\6\5\4\3\15\5\5\3\3\5\1\3&quot;+
    &quot;\7\5\16\3\5\0\32\3\5\0\20\3\2\5\23\3&quot;+
    &quot;\1\5\13\3\5\0\1\3\12\0\1\3\1\5\15\3&quot;+
    &quot;\1\5\20\3\15\5\3\3\40\5\20\3\15\0\4\3&quot;+
    &quot;\1\0\3\3\14\0\21\3\1\5\4\3\1\5\2\3&quot;+
    &quot;\12\5\1\3\1\5\3\3\5\5\6\3\1\5\1\3&quot;+
    &quot;\1\5\1\3\1\5\1\3\4\5\1\3\13\5\2\3&quot;+
    &quot;\4\5\5\3\5\5\4\3\1\5\21\3\51\5\u0177\3&quot;+
    &quot;\57\5\1\3\57\5\1\3\205\5\6\3\4\5\3\0&quot;+
    &quot;\2\5\14\3\46\5\1\3\1\5\5\3\1\5\2\3&quot;+
    &quot;\70\5\7\3\1\5\17\3\1\0\27\5\11\3\7\5&quot;+
    &quot;\1\3\7\5\1\3\7\5\1\3\7\5\1\3\7\5&quot;+
    &quot;\1\3\7\5\1\3\7\5\1\3\7\5\1\3\40\0&quot;+
    &quot;\57\3\1\5\325\3\3\5\31\3\11\5\6\0\1\3&quot;+
    &quot;\5\5\2\3\5\5\4\3\126\5\2\3\2\0\2\3&quot;+
    &quot;\3\5\1\3\132\5\1\3\4\5\5\3\52\5\2\3&quot;+
    &quot;\136\5\21\3\33\5\65\3\306\5\112\3\353\5\25\3&quot;+
    &quot;\215\5\103\3\56\5\2\3\15\5\3\3\20\5\12\0&quot;+
    &quot;\2\5\24\3\57\5\1\0\4\3\12\0\1\3\37\5&quot;+
    &quot;\2\0\120\5\2\0\45\3\11\5\2\3\147\5\2\3&quot;+
    &quot;\44\5\1\3\10\5\77\3\13\5\1\0\3\5\1\0&quot;+
    &quot;\4\5\1\0\27\5\5\0\20\3\1\5\7\3\64\5&quot;+
    &quot;\14\3\2\0\62\5\22\0\12\3\12\0\6\3\22\0&quot;+
    &quot;\6\5\3\3\1\5\1\3\1\5\2\3\12\0\34\5&quot;+
    &quot;\10\0\2\3\27\5\15\0\14\3\35\5\3\3\4\0&quot;+
    &quot;\57\5\16\0\16\3\1\5\12\0\6\3\5\5\1\0&quot;+
    &quot;\12\5\12\0\5\5\1\3\51\5\16\0\11\3\3\5&quot;+
    &quot;\1\0\10\5\2\0\2\3\12\0\6\3\27\5\3\3&quot;+
    &quot;\1\5\3\0\62\5\1\0\1\5\3\0\2\5\2\0&quot;+
    &quot;\5\5\2\0\1\5\1\0\1\5\30\3\3\5\2\3&quot;+
    &quot;\13\5\5\0\2\3\3\5\2\0\12\3\6\5\2\3&quot;+
    &quot;\6\5\2\3\6\5\11\3\7\5\1\3\7\5\1\3&quot;+
    &quot;\53\5\1\3\12\5\12\3\163\5\10\0\1\3\2\0&quot;+
    &quot;\2\3\12\0\6\3\244\5\14\3\27\5\4\3\61\5&quot;+
    &quot;\4\3\156\5\2\3\152\5\46\3\7\5\14\3\5\5&quot;+
    &quot;\5\3\1\5\1\0\12\5\1\3\15\5\1\3\5\5&quot;+
    &quot;\1\3\1\5\1\3\2\5\1\3\2\5\1\3\154\5&quot;+
    &quot;\41\3\153\5\22\3\100\5\2\3\66\5\50\3\15\5&quot;+
    &quot;\3\3\20\0\20\3\20\0\3\3\2\5\30\3\3\5&quot;+
    &quot;\31\3\1\5\6\3\5\5\1\3\207\5\2\3\1\0&quot;+
    &quot;\4\3\1\5\13\3\12\0\7\3\32\5\4\3\1\5&quot;+
    &quot;\1\3\32\5\13\3\131\5\3\3\6\5\2\3\6\5&quot;+
    &quot;\2\3\6\5\2\3\3\5\3\3\2\5\3\3\2\5&quot;+
    &quot;\22\3\3\0\4\3\14\5\1\3\32\5\1\3\23\5&quot;+
    &quot;\1\3\2\5\1\3\17\5\2\3\16\5\42\3\173\5&quot;+
    &quot;\105\3\65\5\210\3\1\0\202\3\35\5\3\3\61\5&quot;+
    &quot;\17\3\1\0\37\3\40\5\15\3\36\5\5\3\46\5&quot;+
    &quot;\5\0\5\3\36\5\2\3\44\5\4\3\10\5\1\3&quot;+
    &quot;\5\5\52\3\236\5\2\3\12\0\6\3\44\5\4\3&quot;+
    &quot;\44\5\4\3\50\5\10\3\64\5\234\3\67\5\11\3&quot;+
    &quot;\26\5\12\3\10\5\230\3\6\5\2\3\1\5\1\3&quot;+
    &quot;\54\5\1\3\2\5\3\3\1\5\2\3\27\5\12\3&quot;+
    &quot;\27\5\11\3\37\5\101\3\23\5\1\3\2\5\12\3&quot;+
    &quot;\26\5\12\3\32\5\106\3\70\5\6\3\2\5\100\3&quot;+
    &quot;\1\5\3\0\1\3\2\0\5\3\4\0\4\5\1\3&quot;+
    &quot;\3\5\1\3\33\5\4\3\3\0\4\3\1\0\40\3&quot;+
    &quot;\35\5\3\3\35\5\43\3\10\5\1\3\34\5\2\0&quot;+
    &quot;\31\3\66\5\12\3\26\5\12\3\23\5\15\3\22\5&quot;+
    &quot;\156\3\111\5\67\3\63\5\15\3\63\5\15\3\3\0&quot;+
    &quot;\65\5\17\0\37\3\12\0\17\3\4\0\55\5\13\0&quot;+
    &quot;\2\3\1\0\22\3\31\5\7\3\12\0\6\3\3\0&quot;+
    &quot;\44\5\16\0\1\3\12\0\20\3\43\5\1\0\2\3&quot;+
    &quot;\1\5\11\3\3\0\60\5\16\0\4\5\5\3\3\0&quot;+
    &quot;\3\3\12\0\1\5\1\3\1\5\43\3\22\5\1\3&quot;+
    &quot;\31\5\14\0\6\3\1\0\101\3\7\5\1\3\1\5&quot;+
    &quot;\1\3\4\5\1\3\17\5\1\3\12\5\7\3\57\5&quot;+
    &quot;\14\0\5\3\12\0\6\3\4\0\1\3\10\5\2\3&quot;+
    &quot;\2\5\2\3\26\5\1\3\7\5\1\3\2\5\1\3&quot;+
    &quot;\5\5\2\3\1\0\1\5\7\0\2\3\2\0\2\3&quot;+
    &quot;\3\0\2\3\1\5\6\3\1\0\5\3\5\5\2\0&quot;+
    &quot;\2\3\7\0\3\3\5\0\213\3\65\5\22\0\4\5&quot;+
    &quot;\5\3\12\0\46\3\60\5\24\0\2\5\1\3\1\5&quot;+
    &quot;\10\3\12\0\246\3\57\5\7\0\2\3\11\0\27\3&quot;+
    &quot;\4\5\2\0\42\3\60\5\21\0\3\3\1\5\13\3&quot;+
    &quot;\12\0\46\3\53\5\15\0\10\3\12\0\66\3\32\5&quot;+
    &quot;\3\3\17\0\4\3\12\0\u0166\3\100\5\12\0\25\3&quot;+
    &quot;\2\5\12\0\50\5\7\0\1\5\4\0\10\3\1\0&quot;+
    &quot;\10\3\1\5\13\0\50\5\2\3\4\5\20\0\46\3&quot;+
    &quot;\71\5\7\3\11\5\1\3\45\5\10\0\1\3\10\0&quot;+
    &quot;\1\5\17\3\12\0\30\3\36\5\2\3\26\0\1\3&quot;+
    &quot;\16\0\111\3\7\5\1\3\2\5\1\3\46\5\6\0&quot;+
    &quot;\3\3\1\0\1\3\2\0\1\3\7\0\1\5\1\0&quot;+
    &quot;\10\3\12\0\246\3\232\5\146\3\157\5\21\3\304\5&quot;+
    &quot;\274\3\57\5\321\3\107\5\271\3\71\5\7\3\37\5&quot;+
    &quot;\1\3\12\0\146\3\36\5\2\3\5\0\13\3\60\5&quot;+
    &quot;\7\0\11\3\4\5\14\3\12\0\11\3\25\5\5\3&quot;+
    &quot;\23\5\160\3\105\5\13\3\1\5\56\0\20\3\4\0&quot;+
    &quot;\15\5\100\3\2\5\36\3\355\5\23\3\363\5\15\3&quot;+
    &quot;\37\5\121\3\u018c\5\4\3\153\5\5\3\15\5\3\3&quot;+
    &quot;\11\5\7\3\12\5\3\3\2\0\1\3\4\0\301\3&quot;+
    &quot;\5\0\3\3\26\0\2\3\7\0\36\3\4\0\224\3&quot;+
    &quot;\3\0\273\3\125\5\1\3\107\5\1\3\2\5\2\3&quot;+
    &quot;\1\5\2\3\2\5\2\3\4\5\1\3\14\5\1\3&quot;+
    &quot;\1\5\1\3\7\5\1\3\101\5\1\3\4\5\2\3&quot;+
    &quot;\10\5\1\3\7\5\1\3\34\5\1\3\4\5\1\3&quot;+
    &quot;\5\5\1\3\1\5\3\3\7\5\1\3\u0154\5\2\3&quot;+
    &quot;\31\5\1\3\31\5\1\3\37\5\1\3\31\5\1\3&quot;+
    &quot;\37\5\1\3\31\5\1\3\37\5\1\3\31\5\1\3&quot;+
    &quot;\37\5\1\3\31\5\1\3\10\5\2\3\151\0\4\3&quot;+
    &quot;\62\0\10\3\1\0\16\3\1\0\26\3\5\0\1\3&quot;+
    &quot;\17\0\120\3\7\0\1\3\21\0\2\3\7\0\1\3&quot;+
    &quot;\2\0\1\3\5\0\325\3\305\5\13\3\7\0\51\3&quot;+
    &quot;\104\5\7\0\5\3\12\0\246\3\4\5\1\3\33\5&quot;+
    &quot;\1\3\2\5\1\3\1\5\2\3\1\5\1\3\12\5&quot;+
    &quot;\1\3\4\5\1\3\1\5\1\3\1\5\6\3\1\5&quot;+
    &quot;\4\3\1\5\1\3\1\5\1\3\1\5\1\3\3\5&quot;+
    &quot;\1\3\2\5\1\3\1\5\2\3\1\5\1\3\1\5&quot;+
    &quot;\1\3\1\5\1\3\1\5\1\3\1\5\1\3\2\5&quot;+
    &quot;\1\3\1\5\2\3\4\5\1\3\7\5\1\3\4\5&quot;+
    &quot;\1\3\4\5\1\3\1\5\1\3\12\5\1\3\21\5&quot;+
    &quot;\5\3\3\5\1\3\5\5\1\3\21\5\104\3\327\5&quot;+
    &quot;\51\3\65\5\13\3\336\5\2\3\u0182\5\16\3\u0131\5&quot;+
    &quot;\37\3\36\5\343\3\1\0\36\3\140\0\200\3\360\0&quot;+
    &quot;\20\3&quot;;

  private static int [] zzUnpackcmap_blocks() {
<span class="fc" id="L299">    int [] result = new int[27648];</span>
<span class="fc" id="L300">    int offset = 0;</span>
<span class="fc" id="L301">    offset = zzUnpackcmap_blocks(ZZ_CMAP_BLOCKS_PACKED_0, offset, result);</span>
<span class="fc" id="L302">    return result;</span>
  }

  private static int zzUnpackcmap_blocks(String packed, int offset, int [] result) {
<span class="fc" id="L306">    int i = 0;       /* index in packed string  */</span>
<span class="fc" id="L307">    int j = offset;  /* index in unpacked array */</span>
<span class="fc" id="L308">    int l = packed.length();</span>
<span class="fc bfc" id="L309" title="All 2 branches covered.">    while (i &lt; l) {</span>
<span class="fc" id="L310">      int count = packed.charAt(i++);</span>
<span class="fc" id="L311">      int value = packed.charAt(i++);</span>
<span class="fc bfc" id="L312" title="All 2 branches covered.">      do result[j++] = value; while (--count &gt; 0);</span>
<span class="fc" id="L313">    }</span>
<span class="fc" id="L314">    return j;</span>
  }

  /**
   * Translates DFA states to action switch labels.
   */
<span class="fc" id="L320">  private static final int [] ZZ_ACTION = zzUnpackAction();</span>

  private static final String ZZ_ACTION_PACKED_0 =
    &quot;\1\0\1\1\2\2\1\3\1\4\1\5\1\6\1\0&quot;+
    &quot;\1\7&quot;;

  private static int [] zzUnpackAction() {
<span class="fc" id="L327">    int [] result = new int[10];</span>
<span class="fc" id="L328">    int offset = 0;</span>
<span class="fc" id="L329">    offset = zzUnpackAction(ZZ_ACTION_PACKED_0, offset, result);</span>
<span class="fc" id="L330">    return result;</span>
  }

  private static int zzUnpackAction(String packed, int offset, int [] result) {
<span class="fc" id="L334">    int i = 0;       /* index in packed string  */</span>
<span class="fc" id="L335">    int j = offset;  /* index in unpacked array */</span>
<span class="fc" id="L336">    int l = packed.length();</span>
<span class="fc bfc" id="L337" title="All 2 branches covered.">    while (i &lt; l) {</span>
<span class="fc" id="L338">      int count = packed.charAt(i++);</span>
<span class="fc" id="L339">      int value = packed.charAt(i++);</span>
<span class="fc bfc" id="L340" title="All 2 branches covered.">      do result[j++] = value; while (--count &gt; 0);</span>
<span class="fc" id="L341">    }</span>
<span class="fc" id="L342">    return j;</span>
  }


  /**
   * Translates a state to a row index in the transition table
   */
<span class="fc" id="L349">  private static final int [] ZZ_ROWMAP = zzUnpackRowMap();</span>

  private static final String ZZ_ROWMAP_PACKED_0 =
    &quot;\0\0\0\12\0\12\0\24\0\36\0\12\0\50\0\62&quot;+
    &quot;\0\50\0\12&quot;;

  private static int [] zzUnpackRowMap() {
<span class="fc" id="L356">    int [] result = new int[10];</span>
<span class="fc" id="L357">    int offset = 0;</span>
<span class="fc" id="L358">    offset = zzUnpackRowMap(ZZ_ROWMAP_PACKED_0, offset, result);</span>
<span class="fc" id="L359">    return result;</span>
  }

  private static int zzUnpackRowMap(String packed, int offset, int [] result) {
<span class="fc" id="L363">    int i = 0;  /* index in packed string  */</span>
<span class="fc" id="L364">    int j = offset;  /* index in unpacked array */</span>
<span class="fc" id="L365">    int l = packed.length();</span>
<span class="fc bfc" id="L366" title="All 2 branches covered.">    while (i &lt; l) {</span>
<span class="fc" id="L367">      int high = packed.charAt(i++) &lt;&lt; 16;</span>
<span class="fc" id="L368">      result[j++] = high | packed.charAt(i++);</span>
<span class="fc" id="L369">    }</span>
<span class="fc" id="L370">    return j;</span>
  }

  /**
   * The transition table of the DFA
   */
<span class="fc" id="L376">  private static final int [] ZZ_TRANS = zzUnpackTrans();</span>

  private static final String ZZ_TRANS_PACKED_0 =
    &quot;\1\2\2\3\1\2\1\4\1\5\1\6\1\7\1\10&quot;+
    &quot;\1\5\14\0\1\3\7\0\1\5\4\0\1\5\1\0&quot;+
    &quot;\1\5\1\0\1\5\7\0\1\7\1\0\1\11\10\0&quot;+
    &quot;\1\12\1\0&quot;;

  private static int [] zzUnpackTrans() {
<span class="fc" id="L385">    int [] result = new int[60];</span>
<span class="fc" id="L386">    int offset = 0;</span>
<span class="fc" id="L387">    offset = zzUnpackTrans(ZZ_TRANS_PACKED_0, offset, result);</span>
<span class="fc" id="L388">    return result;</span>
  }

  private static int zzUnpackTrans(String packed, int offset, int [] result) {
<span class="fc" id="L392">    int i = 0;       /* index in packed string  */</span>
<span class="fc" id="L393">    int j = offset;  /* index in unpacked array */</span>
<span class="fc" id="L394">    int l = packed.length();</span>
<span class="fc bfc" id="L395" title="All 2 branches covered.">    while (i &lt; l) {</span>
<span class="fc" id="L396">      int count = packed.charAt(i++);</span>
<span class="fc" id="L397">      int value = packed.charAt(i++);</span>
<span class="fc" id="L398">      value--;</span>
<span class="fc bfc" id="L399" title="All 2 branches covered.">      do result[j++] = value; while (--count &gt; 0);</span>
<span class="fc" id="L400">    }</span>
<span class="fc" id="L401">    return j;</span>
  }


  /** Error code for &quot;Unknown internal scanner error&quot;. */
  private static final int ZZ_UNKNOWN_ERROR = 0;
  /** Error code for &quot;could not match input&quot;. */
  private static final int ZZ_NO_MATCH = 1;
  /** Error code for &quot;pushback value was too large&quot;. */
  private static final int ZZ_PUSHBACK_2BIG = 2;

  /**
   * Error messages for {@link #ZZ_UNKNOWN_ERROR}, {@link #ZZ_NO_MATCH}, and
   * {@link #ZZ_PUSHBACK_2BIG} respectively.
   */
<span class="fc" id="L416">  private static final String ZZ_ERROR_MSG[] = {</span>
    &quot;Unknown internal scanner error&quot;,
    &quot;Error: could not match input&quot;,
    &quot;Error: pushback value was too large&quot;
  };

  /**
   * ZZ_ATTRIBUTE[aState] contains the attributes of state {@code aState}
   */
<span class="fc" id="L425">  private static final int [] ZZ_ATTRIBUTE = zzUnpackAttribute();</span>

  private static final String ZZ_ATTRIBUTE_PACKED_0 =
    &quot;\1\0\2\11\2\1\1\11\2\1\1\0\1\11&quot;;

  private static int [] zzUnpackAttribute() {
<span class="fc" id="L431">    int [] result = new int[10];</span>
<span class="fc" id="L432">    int offset = 0;</span>
<span class="fc" id="L433">    offset = zzUnpackAttribute(ZZ_ATTRIBUTE_PACKED_0, offset, result);</span>
<span class="fc" id="L434">    return result;</span>
  }

  private static int zzUnpackAttribute(String packed, int offset, int [] result) {
<span class="fc" id="L438">    int i = 0;       /* index in packed string  */</span>
<span class="fc" id="L439">    int j = offset;  /* index in unpacked array */</span>
<span class="fc" id="L440">    int l = packed.length();</span>
<span class="fc bfc" id="L441" title="All 2 branches covered.">    while (i &lt; l) {</span>
<span class="fc" id="L442">      int count = packed.charAt(i++);</span>
<span class="fc" id="L443">      int value = packed.charAt(i++);</span>
<span class="fc bfc" id="L444" title="All 2 branches covered.">      do result[j++] = value; while (--count &gt; 0);</span>
<span class="fc" id="L445">    }</span>
<span class="fc" id="L446">    return j;</span>
  }

  /** Input device. */
  private java.io.Reader zzReader;

  /** Current state of the DFA. */
  private int zzState;

  /** Current lexical state. */
<span class="fc" id="L456">  private int zzLexicalState = YYINITIAL;</span>

  /**
   * This buffer contains the current text to be matched and is the source of the {@link #yytext()}
   * string.
   */
<span class="fc" id="L462">  private char zzBuffer[] = new char[ZZ_BUFFERSIZE];</span>

  /** Text position at the last accepting state. */
  private int zzMarkedPos;

  /** Current text position in the buffer. */
  private int zzCurrentPos;

  /** Marks the beginning of the {@link #yytext()} string in the buffer. */
  private int zzStartRead;

  /** Marks the last character in the buffer, that has been read from input. */
  private int zzEndRead;

  /**
   * Whether the scanner is at the end of file.
   * @see #yyatEOF
   */
  private boolean zzAtEOF;

  /**
   * The number of occupied positions in {@link #zzBuffer} beyond {@link #zzEndRead}.
   *
   * &lt;p&gt;When a lead/high surrogate has been read from the input stream into the final
   * {@link #zzBuffer} position, this will have a value of 1; otherwise, it will have a value of 0.
   */
<span class="fc" id="L488">  private int zzFinalHighSurrogate = 0;</span>

  /** Number of newlines encountered up to the start of the matched text. */
  private int yyline;

  /** Number of characters from the last newline up to the start of the matched text. */
  private int yycolumn;

  /** Number of characters up to the start of the matched text. */
  @SuppressWarnings(&quot;unused&quot;)
  private long yychar;

  /** Whether the scanner is currently at the beginning of a line. */
<span class="fc" id="L501">  @SuppressWarnings(&quot;unused&quot;)</span>
  private boolean zzAtBOL = true;

  /** Whether the user-EOF-code has already been executed. */
  @SuppressWarnings(&quot;unused&quot;)
  private boolean zzEOFDone;

  /* user code: */
<span class="fc" id="L509">  StringBuilder string = new StringBuilder();</span>
  
  private token symbol(TokenTypes type) {
<span class="fc" id="L512">    return new token(type, yyline+1, yycolumn+1);</span>
  }

  private token symbol(TokenTypes type, String value) {
<span class="fc" id="L516">    return new token(type, yyline+1, yycolumn+1, value);</span>
  }



  /**
   * Creates a new scanner
   *
   * @param   in  the java.io.Reader to read input from.
   */
<span class="fc" id="L526">  public GeneratedScanner(java.io.Reader in) {</span>
<span class="fc" id="L527">    this.zzReader = in;</span>
<span class="fc" id="L528">  }</span>

  /**
   * Translates raw input code points to DFA table row
   */
  private static int zzCMap(int input) {
<span class="fc" id="L534">    int offset = input &amp; 255;</span>
<span class="pc bpc" id="L535" title="1 of 2 branches missed.">    return offset == input ? ZZ_CMAP_BLOCKS[offset] : ZZ_CMAP_BLOCKS[ZZ_CMAP_TOP[input &gt;&gt; 8] | offset];</span>
  }

  /**
   * Refills the input buffer.
   *
   * @return {@code false} iff there was new input.
   * @exception java.io.IOException  if any I/O-Error occurs
   */
  private boolean zzRefill() throws java.io.IOException {

    /* first: make room (if you can) */
<span class="fc bfc" id="L547" title="All 2 branches covered.">    if (zzStartRead &gt; 0) {</span>
<span class="fc" id="L548">      zzEndRead += zzFinalHighSurrogate;</span>
<span class="fc" id="L549">      zzFinalHighSurrogate = 0;</span>
<span class="fc" id="L550">      System.arraycopy(zzBuffer, zzStartRead,</span>
                       zzBuffer, 0,
                       zzEndRead - zzStartRead);

      /* translate stored positions */
<span class="fc" id="L555">      zzEndRead -= zzStartRead;</span>
<span class="fc" id="L556">      zzCurrentPos -= zzStartRead;</span>
<span class="fc" id="L557">      zzMarkedPos -= zzStartRead;</span>
<span class="fc" id="L558">      zzStartRead = 0;</span>
    }

    /* is the buffer big enough? */
<span class="pc bpc" id="L562" title="1 of 2 branches missed.">    if (zzCurrentPos &gt;= zzBuffer.length - zzFinalHighSurrogate) {</span>
      /* if not: blow it up */
<span class="nc" id="L564">      char newBuffer[] = new char[zzBuffer.length * 2];</span>
<span class="nc" id="L565">      System.arraycopy(zzBuffer, 0, newBuffer, 0, zzBuffer.length);</span>
<span class="nc" id="L566">      zzBuffer = newBuffer;</span>
<span class="nc" id="L567">      zzEndRead += zzFinalHighSurrogate;</span>
<span class="nc" id="L568">      zzFinalHighSurrogate = 0;</span>
    }

    /* fill the buffer with new input */
<span class="fc" id="L572">    int requested = zzBuffer.length - zzEndRead;</span>
<span class="fc" id="L573">    int numRead = zzReader.read(zzBuffer, zzEndRead, requested);</span>

    /* not supposed to occur according to specification of java.io.Reader */
<span class="pc bpc" id="L576" title="1 of 2 branches missed.">    if (numRead == 0) {</span>
<span class="nc" id="L577">      throw new java.io.IOException(</span>
          &quot;Reader returned 0 characters. See JFlex examples/zero-reader for a workaround.&quot;);
    }
<span class="fc bfc" id="L580" title="All 2 branches covered.">    if (numRead &gt; 0) {</span>
<span class="fc" id="L581">      zzEndRead += numRead;</span>
<span class="pc bpc" id="L582" title="1 of 2 branches missed.">      if (Character.isHighSurrogate(zzBuffer[zzEndRead - 1])) {</span>
<span class="nc bnc" id="L583" title="All 2 branches missed.">        if (numRead == requested) { // We requested too few chars to encode a full Unicode character</span>
<span class="nc" id="L584">          --zzEndRead;</span>
<span class="nc" id="L585">          zzFinalHighSurrogate = 1;</span>
        } else {                    // There is room in the buffer for at least one more char
<span class="nc" id="L587">          int c = zzReader.read();  // Expecting to read a paired low surrogate char</span>
<span class="nc bnc" id="L588" title="All 2 branches missed.">          if (c == -1) {</span>
<span class="nc" id="L589">            return true;</span>
          } else {
<span class="nc" id="L591">            zzBuffer[zzEndRead++] = (char)c;</span>
          }
        }
      }
      /* potentially more input available */
<span class="fc" id="L596">      return false;</span>
    }

    /* numRead &lt; 0 ==&gt; end of stream */
<span class="fc" id="L600">    return true;</span>
  }


  /**
   * Closes the input reader.
   *
   * @throws java.io.IOException if the reader could not be closed.
   */
  public final void yyclose() throws java.io.IOException {
<span class="nc" id="L610">    zzAtEOF = true; // indicate end of file</span>
<span class="nc" id="L611">    zzEndRead = zzStartRead; // invalidate buffer</span>

<span class="nc bnc" id="L613" title="All 2 branches missed.">    if (zzReader != null) {</span>
<span class="nc" id="L614">      zzReader.close();</span>
    }
<span class="nc" id="L616">  }</span>


  /**
   * Resets the scanner to read from a new input stream.
   *
   * &lt;p&gt;Does not close the old reader.
   *
   * &lt;p&gt;All internal variables are reset, the old input stream &lt;b&gt;cannot&lt;/b&gt; be reused (internal
   * buffer is discarded and lost). Lexical state is set to {@code ZZ_INITIAL}.
   *
   * &lt;p&gt;Internal scan buffer is resized down to its initial length, if it has grown.
   *
   * @param reader The new input stream.
   */
  public final void yyreset(java.io.Reader reader) {
<span class="nc" id="L632">    zzReader = reader;</span>
<span class="nc" id="L633">    zzEOFDone = false;</span>
<span class="nc" id="L634">    yyResetPosition();</span>
<span class="nc" id="L635">    zzLexicalState = YYINITIAL;</span>
<span class="nc bnc" id="L636" title="All 2 branches missed.">    if (zzBuffer.length &gt; ZZ_BUFFERSIZE) {</span>
<span class="nc" id="L637">      zzBuffer = new char[ZZ_BUFFERSIZE];</span>
    }
<span class="nc" id="L639">  }</span>

  /**
   * Resets the input position.
   */
  private final void yyResetPosition() {
<span class="nc" id="L645">      zzAtBOL  = true;</span>
<span class="nc" id="L646">      zzAtEOF  = false;</span>
<span class="nc" id="L647">      zzCurrentPos = 0;</span>
<span class="nc" id="L648">      zzMarkedPos = 0;</span>
<span class="nc" id="L649">      zzStartRead = 0;</span>
<span class="nc" id="L650">      zzEndRead = 0;</span>
<span class="nc" id="L651">      zzFinalHighSurrogate = 0;</span>
<span class="nc" id="L652">      yyline = 0;</span>
<span class="nc" id="L653">      yycolumn = 0;</span>
<span class="nc" id="L654">      yychar = 0L;</span>
<span class="nc" id="L655">  }</span>


  /**
   * Returns whether the scanner has reached the end of the reader it reads from.
   *
   * @return whether the scanner has reached EOF.
   */
  public final boolean yyatEOF() {
<span class="nc" id="L664">    return zzAtEOF;</span>
  }


  /**
   * Returns the current lexical state.
   *
   * @return the current lexical state.
   */
  public final int yystate() {
<span class="nc" id="L674">    return zzLexicalState;</span>
  }


  /**
   * Enters a new lexical state.
   *
   * @param newState the new lexical state
   */
  public final void yybegin(int newState) {
<span class="nc" id="L684">    zzLexicalState = newState;</span>
<span class="nc" id="L685">  }</span>


  /**
   * Returns the text matched by the current regular expression.
   *
   * @return the matched text.
   */
  public final String yytext() {
<span class="fc" id="L694">    return new String(zzBuffer, zzStartRead, zzMarkedPos-zzStartRead);</span>
  }


  /**
   * Returns the character at the given position from the matched text.
   *
   * &lt;p&gt;It is equivalent to {@code yytext().charAt(pos)}, but faster.
   *
   * @param position the position of the character to fetch. A value from 0 to {@code yylength()-1}.
   *
   * @return the character at {@code position}.
   */
  public final char yycharat(int position) {
<span class="nc" id="L708">    return zzBuffer[zzStartRead + position];</span>
  }


  /**
   * How many characters were matched.
   *
   * @return the length of the matched text region.
   */
  public final int yylength() {
<span class="nc" id="L718">    return zzMarkedPos-zzStartRead;</span>
  }


  /**
   * Reports an error that occurred while scanning.
   *
   * &lt;p&gt;In a well-formed scanner (no or only correct usage of {@code yypushback(int)} and a
   * match-all fallback rule) this method will only be called with things that
   * &quot;Can't Possibly Happen&quot;.
   *
   * &lt;p&gt;If this method is called, something is seriously wrong (e.g. a JFlex bug producing a faulty
   * scanner etc.).
   *
   * &lt;p&gt;Usual syntax/scanner level error handling should be done in error fallback rules.
   *
   * @param errorCode the code of the error message to display.
   */
  private static void zzScanError(int errorCode) {
    String message;
    try {
<span class="nc" id="L739">      message = ZZ_ERROR_MSG[errorCode];</span>
<span class="nc" id="L740">    } catch (ArrayIndexOutOfBoundsException e) {</span>
<span class="nc" id="L741">      message = ZZ_ERROR_MSG[ZZ_UNKNOWN_ERROR];</span>
<span class="nc" id="L742">    }</span>

<span class="nc" id="L744">    throw new Error(message);</span>
  }


  /**
   * Pushes the specified amount of characters back into the input stream.
   *
   * &lt;p&gt;They will be read again by then next call of the scanning method.
   *
   * @param number the number of characters to be read again. This number must not be greater than
   *     {@link #yylength()}.
   */
  public void yypushback(int number)  {
<span class="nc bnc" id="L757" title="All 2 branches missed.">    if ( number &gt; yylength() )</span>
<span class="nc" id="L758">      zzScanError(ZZ_PUSHBACK_2BIG);</span>

<span class="nc" id="L760">    zzMarkedPos -= number;</span>
<span class="nc" id="L761">  }</span>




  /**
   * Resumes scanning until the next regular expression is matched, the end of input is encountered
   * or an I/O-Error occurs.
   *
   * @return the next token.
   * @exception java.io.IOException if any I/O-Error occurs.
   */
  public token yylex() throws java.io.IOException {
    int zzInput;
    int zzAction;

    // cached fields:
    int zzCurrentPosL;
    int zzMarkedPosL;
<span class="fc" id="L780">    int zzEndReadL = zzEndRead;</span>
<span class="fc" id="L781">    char[] zzBufferL = zzBuffer;</span>

<span class="fc" id="L783">    int [] zzTransL = ZZ_TRANS;</span>
<span class="fc" id="L784">    int [] zzRowMapL = ZZ_ROWMAP;</span>
<span class="fc" id="L785">    int [] zzAttrL = ZZ_ATTRIBUTE;</span>

    while (true) {
<span class="fc" id="L788">      zzMarkedPosL = zzMarkedPos;</span>

<span class="fc" id="L790">      boolean zzR = false;</span>
      int zzCh;
      int zzCharCount;
<span class="fc" id="L793">      for (zzCurrentPosL = zzStartRead  ;</span>
<span class="fc bfc" id="L794" title="All 2 branches covered.">           zzCurrentPosL &lt; zzMarkedPosL ;</span>
<span class="fc" id="L795">           zzCurrentPosL += zzCharCount ) {</span>
<span class="fc" id="L796">        zzCh = Character.codePointAt(zzBufferL, zzCurrentPosL, zzMarkedPosL);</span>
<span class="fc" id="L797">        zzCharCount = Character.charCount(zzCh);</span>
<span class="pc bpc" id="L798" title="3 of 4 branches missed.">        switch (zzCh) {</span>
        case '\u000B':  // fall through
        case '\u000C':  // fall through
        case '\u0085':  // fall through
        case '\u2028':  // fall through
        case '\u2029':
<span class="nc" id="L804">          yyline++;</span>
<span class="nc" id="L805">          yycolumn = 0;</span>
<span class="nc" id="L806">          zzR = false;</span>
<span class="nc" id="L807">          break;</span>
        case '\r':
<span class="nc" id="L809">          yyline++;</span>
<span class="nc" id="L810">          yycolumn = 0;</span>
<span class="nc" id="L811">          zzR = true;</span>
<span class="nc" id="L812">          break;</span>
        case '\n':
<span class="nc bnc" id="L814" title="All 2 branches missed.">          if (zzR)</span>
<span class="nc" id="L815">            zzR = false;</span>
          else {
<span class="nc" id="L817">            yyline++;</span>
<span class="nc" id="L818">            yycolumn = 0;</span>
          }
<span class="nc" id="L820">          break;</span>
        default:
<span class="fc" id="L822">          zzR = false;</span>
<span class="fc" id="L823">          yycolumn += zzCharCount;</span>
        }
      }

<span class="pc bpc" id="L827" title="1 of 2 branches missed.">      if (zzR) {</span>
        // peek one character ahead if it is
        // (if we have counted one line too much)
        boolean zzPeek;
<span class="nc bnc" id="L831" title="All 2 branches missed.">        if (zzMarkedPosL &lt; zzEndReadL)</span>
<span class="nc bnc" id="L832" title="All 2 branches missed.">          zzPeek = zzBufferL[zzMarkedPosL] == '\n';</span>
<span class="nc bnc" id="L833" title="All 2 branches missed.">        else if (zzAtEOF)</span>
<span class="nc" id="L834">          zzPeek = false;</span>
        else {
<span class="nc" id="L836">          boolean eof = zzRefill();</span>
<span class="nc" id="L837">          zzEndReadL = zzEndRead;</span>
<span class="nc" id="L838">          zzMarkedPosL = zzMarkedPos;</span>
<span class="nc" id="L839">          zzBufferL = zzBuffer;</span>
<span class="nc bnc" id="L840" title="All 2 branches missed.">          if (eof)</span>
<span class="nc" id="L841">            zzPeek = false;</span>
          else
<span class="nc bnc" id="L843" title="All 2 branches missed.">            zzPeek = zzBufferL[zzMarkedPosL] == '\n';</span>
        }
<span class="nc bnc" id="L845" title="All 2 branches missed.">        if (zzPeek) yyline--;</span>
      }
<span class="fc" id="L847">      zzAction = -1;</span>

<span class="fc" id="L849">      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;</span>

<span class="fc" id="L851">      zzState = ZZ_LEXSTATE[zzLexicalState];</span>

      // set up zzAction for empty match case:
<span class="fc" id="L854">      int zzAttributes = zzAttrL[zzState];</span>
<span class="pc bpc" id="L855" title="1 of 2 branches missed.">      if ( (zzAttributes &amp; 1) == 1 ) {</span>
<span class="nc" id="L856">        zzAction = zzState;</span>
      }


      zzForAction: {
        while (true) {

<span class="fc bfc" id="L863" title="All 2 branches covered.">          if (zzCurrentPosL &lt; zzEndReadL) {</span>
<span class="fc" id="L864">            zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);</span>
<span class="fc" id="L865">            zzCurrentPosL += Character.charCount(zzInput);</span>
          }
<span class="pc bpc" id="L867" title="1 of 2 branches missed.">          else if (zzAtEOF) {</span>
<span class="nc" id="L868">            zzInput = YYEOF;</span>
<span class="nc" id="L869">            break zzForAction;</span>
          }
          else {
            // store back cached positions
<span class="fc" id="L873">            zzCurrentPos  = zzCurrentPosL;</span>
<span class="fc" id="L874">            zzMarkedPos   = zzMarkedPosL;</span>
<span class="fc" id="L875">            boolean eof = zzRefill();</span>
            // get translated positions and possibly new buffer
<span class="fc" id="L877">            zzCurrentPosL  = zzCurrentPos;</span>
<span class="fc" id="L878">            zzMarkedPosL   = zzMarkedPos;</span>
<span class="fc" id="L879">            zzBufferL      = zzBuffer;</span>
<span class="fc" id="L880">            zzEndReadL     = zzEndRead;</span>
<span class="fc bfc" id="L881" title="All 2 branches covered.">            if (eof) {</span>
<span class="fc" id="L882">              zzInput = YYEOF;</span>
<span class="fc" id="L883">              break zzForAction;</span>
            }
            else {
<span class="fc" id="L886">              zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);</span>
<span class="fc" id="L887">              zzCurrentPosL += Character.charCount(zzInput);</span>
            }
          }
<span class="fc" id="L890">          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMap(zzInput) ];</span>
<span class="fc bfc" id="L891" title="All 2 branches covered.">          if (zzNext == -1) break zzForAction;</span>
<span class="fc" id="L892">          zzState = zzNext;</span>

<span class="fc" id="L894">          zzAttributes = zzAttrL[zzState];</span>
<span class="pc bpc" id="L895" title="1 of 2 branches missed.">          if ( (zzAttributes &amp; 1) == 1 ) {</span>
<span class="fc" id="L896">            zzAction = zzState;</span>
<span class="fc" id="L897">            zzMarkedPosL = zzCurrentPosL;</span>
<span class="fc bfc" id="L898" title="All 2 branches covered.">            if ( (zzAttributes &amp; 8) == 8 ) break zzForAction;</span>
          }

<span class="fc" id="L901">        }</span>
      }

      // store back cached position
<span class="fc" id="L905">      zzMarkedPos = zzMarkedPosL;</span>

<span class="fc bfc" id="L907" title="All 4 branches covered.">      if (zzInput == YYEOF &amp;&amp; zzStartRead == zzCurrentPos) {</span>
<span class="fc" id="L908">        zzAtEOF = true;</span>
              {
<span class="fc" id="L910">                return symbol(TokenTypes.EOF);</span>
              }
      }
      else {
<span class="pc bpc" id="L914" title="11 of 16 branches missed.">        switch (zzAction &lt; 0 ? zzAction : ZZ_ACTION[zzAction]) {</span>
          case 1:
<span class="nc" id="L916">            { throw new RuntimeException(&quot;Illegal character \&quot;&quot;+yytext()+</span>
                                            &quot;\&quot; at line &quot;+yyline+&quot;, column &quot;+yycolumn);
            }
            // fall through
<span class="nc" id="L920">          case 8: break;</span>
          case 2:
            { /* Ignore: don't return anything. */
            }
            // fall through
<span class="fc" id="L925">          case 9: break;</span>
          case 3:
<span class="fc" id="L927">            { return symbol(TokenTypes.IDENTIFIER, yytext());</span>
            }
            // fall through
<span class="nc" id="L930">          case 10: break;</span>
          case 4:
<span class="nc" id="L932">            { return symbol(TokenTypes.PLUS);</span>
            }
            // fall through
<span class="nc" id="L935">          case 11: break;</span>
          case 5:
<span class="fc" id="L937">            { return symbol(TokenTypes.INTEGER_LITERAL, yytext());</span>
            }
            // fall through
<span class="nc" id="L940">          case 12: break;</span>
          case 6:
<span class="fc" id="L942">            { return symbol(TokenTypes.EQ);</span>
            }
            // fall through
<span class="nc" id="L945">          case 13: break;</span>
          case 7:
<span class="nc" id="L947">            { return symbol(TokenTypes.EQEQ);</span>
            }
            // fall through
<span class="nc" id="L950">          case 14: break;</span>
          default:
<span class="nc" id="L952">            zzScanError(ZZ_NO_MATCH);</span>
        }
      }
<span class="fc" id="L955">    }</span>
  }


}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>